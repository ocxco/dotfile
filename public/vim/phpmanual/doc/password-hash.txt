password_hash -- Creates a password hash

  string password_hash(string password, integer algo [, array options])~

|password_hash| creates a new password hash using a strong one-way hashing
algorithm.

The following algorithms are currently supported:

PASSWORD_DEFAULT - Use the bcrypt algorithm (default as of PHP 5.5.0). Note
that this constant is designed to change over time as new and stronger
algorithms are added to PHP. For that reason, the length of the result from
using this identifier can change over time. Therefore, it is recommended to
store the result in a database column that can expand beyond 60 characters
(255 characters would be a good choice).

PASSWORD_BCRYPT - Use the CRYPT_BLOWFISH algorithm to create the hash. This
will produce a standard |crypt| compatible hash using the "$2y$" identifier.
The result will always be a 60 character string, or &false; on failure.

Supported Options:

salt - to manually provide a salt to use when hashing the password. Note that
this will override and prevent a salt from being automatically generated.

If omitted, a random salt will be generated by |password_hash| for each
password hashed. This is the intended mode of operation.

cost - which denotes the algorithmic cost that should be used. Examples of
these values can be found on the |crypt| page.

If ommitted, a default value of 10 will be used. This is a good baseline cost,
but you may want to consider increasing it depending on your hardware.

The user"s password.

A password algorithm constant denoting the algorithm to use when hashing the
password.

An associative array containing options. See the password algorithm constants
for documentation on the supported options for each algorithm.

If omitted, a random salt will be created and the default cost will be used.

Returns the hashed password, or &false; on failure.

|password_hash| example

<?php >
  /**
   * We just want to hash our password using the current DEFAULT algorithm.
   * This is presently BCRYPT, and will produce a 60 character result.
   *
   * Beware that DEFAULT may change over time, so you would want to prepare
   * By allowing your storage to expand past 60 characters (255 would be good)
   */
  echo password_hash("rasmuslerdorf", PASSWORD_DEFAULT)."\n";
?>

The above example will output:

  $2y$10$.vGA1O9wmRjrwAVXD98HNOgsNpDczlqm3Jq7KnEd1rVAGv3Fykk1a



|password_hash| example setting cost manually

<?php >
  /**
   * In this case, we want to increase the default cost for BCRYPT to 12.
   * Note that we also switched to BCRYPT, which will always be 60 characters.
   */
  $options = [
      'cost' => 12,
  ];
  echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options)."\n";
?>

The above example will output:

  $2y$12$QjSH496pcT5CEbzjD/vtVeH03tfHKFy36d4J0Ltp3lRtee9HDxY3K



|password_hash| example setting salt manually

<?php >
  /**
   * Note that the salt here is randomly generated.
   * Never use a static salt or one that is not randomly generated.
   *
   * For the VAST majority of use-cases, let password_hash generate the salt randomly for you
   */
  $options = [
      'cost' => 11,
      'salt' => mcrypt_create_iv(22, MCRYPT_DEV_URANDOM),
  ];
  echo password_hash("rasmuslerdorf", PASSWORD_BCRYPT, $options)."\n";
?>

The above example will output:

  $2y$11$q5MkhSBtlsJcNEVsYh64a.aCluzHnGog7TQAKVmQwO9C8xb.t89F.



|password_hash| example finding a good cost

<?php >
  /**
   * This code will benchmark your server to determine how high of a cost you can
   * afford. You want to set the highest cost that you can without slowing down
   * you server too much. 10 is a good baseline, and more is good if your servers
   * are fast enough.
   */
  $timeTarget = 0.2; 
  
  $cost = 9;
  do {
      $cost++;
      $start = microtime(true);
      password_hash("test", PASSWORD_BCRYPT, ["cost" => $cost]);
      $end = microtime(true);
  } while (($end - $start) < $timeTarget);
  
  echo "Appropriate Cost Found: " . $cost . "\n";
?>

The above example will output:

  Appropriate Cost Found: 11



It is strongly recommended that you do not generate your own salt for this
function. It will create a secure salt automatically for you if you do not
specify one.

It is recommended that you should test this function on your servers, and
adjust the cost parameter so that execution of the function takes
approximately 0.1 to 0.5 seconds. The script in the above example will help
you choose a good cost value for your hardware.

Updates to supported algorithms by this function (or changes to the default
one) must follow the follwoing rules:

Any new algorithm must be in core for at least 1 full release of PHP prior to
becoming default. So if, for example, a new algorithm is added in 5.5.5, it
would not be eligible for default until 5.7 (since 5.6 would be the first full
release). But if a different algorithm was added in 5.6.0, it would also be
eligible for default at 5.7.0.

The default should only change on a full release (5.6.0, 6.0.0, etc) and not
on a revision release. The only exception to this is in an emergency when a
critical security flaw is found in the current default.

|password_verify| |crypt| userland implementation

vim:ft=help:
